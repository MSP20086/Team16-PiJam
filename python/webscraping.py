# -*- coding: utf-8 -*-
"""webscraping.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ctBpU1_OVWYzsMouqlu8EQBenyXH01-z

This script automates the evaluation of hackathon project submissions by checking whether similar ideas already exist. It leverages multiple free search engines (**DuckDuckGo, Yahoo, Mojeek**) to provide a comprehensive solution ranking.

Judges and educators can use this as a **rubric** to assess project originality and relevance. Additionally, it helps identify **how implementable a proposed solution is** by comparing it with existing projects.
"""

pip install requests beautifulsoup4

import requests
from bs4 import BeautifulSoup
import time
import random
import re

SEARCH_ENGINES = ["duckduckgo", "yahoo", "mojeek"]

def duckduckgo_search(query, num_results=3):
    """Search DuckDuckGo and return top results."""
    search_url = f"https://html.duckduckgo.com/html/?q={query.replace(' ', '+')}"
    headers = {"User-Agent": "Mozilla/5.0"}
    response = requests.get(search_url, headers=headers)
    if response.status_code != 200:
        return []
    soup = BeautifulSoup(response.text, "html.parser")
    results = []
    for result in soup.find_all('div', class_='result__body', limit=num_results):
        title = result.find('a', class_='result__a').text if result.find('a', class_='result__a') else "No Title"
        link = result.find('a', class_='result__a')['href'] if result.find('a', class_='result__a') else "No Link"
        snippet = result.find('a', class_='result__snippet').text if result.find('a', class_='result__snippet') else "No Description"
        results.append({"title": title, "link": link, "snippet": snippet, "engine": "DuckDuckGo"})
    return results

def yahoo_search(query, num_results=3):
    """Search Yahoo and return top results."""
    search_url = f"https://search.yahoo.com/search?p={query.replace(' ', '+')}"
    headers = {"User-Agent": "Mozilla/5.0"}
    response = requests.get(search_url, headers=headers)
    if response.status_code != 200:
        return []
    soup = BeautifulSoup(response.text, "html.parser")
    results = []
    for result in soup.find_all('h3', class_='title', limit=num_results):
        link_tag = result.find('a')
        if link_tag:
            results.append({"title": link_tag.text, "link": link_tag['href'], "snippet": "No Description", "engine": "Yahoo"})
    return results

def mojeek_search(query, num_results=3):
    """Search Mojeek and return top results."""
    search_url = f"https://www.mojeek.com/search?q={query.replace(' ', '+')}"
    headers = {"User-Agent": "Mozilla/5.0"}
    response = requests.get(search_url, headers=headers)
    if response.status_code != 200:
        return []
    soup = BeautifulSoup(response.text, "html.parser")
    results = []
    for result in soup.find_all('div', class_='web-result', limit=num_results):
        title_tag = result.find('a')
        if title_tag:
            results.append({"title": title_tag.text, "link": title_tag['href'], "snippet": "No Description", "engine": "Mojeek"})
    return results

def search(query):
    """Rotates through different search engines and fetches results."""
    search_functions = {
        "duckduckgo": duckduckgo_search,
        "yahoo": yahoo_search,
        "mojeek": mojeek_search
    }
    results = []
    random.shuffle(SEARCH_ENGINES)  # Randomize order to distribute load
    for engine in SEARCH_ENGINES:
        #print(f"\nSearching with {engine.capitalize()} for: {query}")
        engine_results = search_functions[engine](query)
        if engine_results:
            results.extend(engine_results)
            time.sleep(random.randint(5, 10))  # Prevent blocking
        if len(results) >= 5:  # Stop once enough results are gathered
            break
    return results

def split_text_into_sentences(text):
    """Splits long text into smaller meaningful sentences."""
    sentences = re.split(r'(?<!\w\.\w.)(?<![A-Z][a-z]\.)(?<=\.|\?)\s', text)
    return [sentence.strip() for sentence in sentences if sentence.strip()]

def rank_results(results, query):
    """Ranks results based on how well they match the query."""
    def relevance_score(result):
        title_match = sum(1 for word in query.split() if word.lower() in result['title'].lower())
        snippet_match = sum(1 for word in query.split() if word.lower() in result['snippet'].lower())
        return title_match + snippet_match

    results.sort(key=relevance_score, reverse=True)
    return results[:5]  # Return top 5 most relevant results

if __name__ == "__main__":
    student_solution = """In many countries, traditional voting systems face challenges such as fraud, lack of transparency,
    and inefficiencies in vote counting. This project aims to develop a blockchain-based e-voting system that ensures security,
    transparency, and immutability of votes. By leveraging blockchain's decentralized nature, every vote is recorded as a transaction
    in a tamper-proof ledger, preventing unauthorized alterations. The system will use smart contracts to automate vote validation and
    counting, ensuring accuracy and eliminating manual errors."""

    search_queries = split_text_into_sentences(student_solution)
    print("\nSearching for similar projects...")
    start_time = time.time()
    combined_results = []

    for query in search_queries:
        results = search(query)
        if results:
            combined_results.extend(results)
    end_time = time.time()
    time_taken = round(end_time - start_time, 2)

    if combined_results:
        print("\nTop 5 Relevant Results:")
        unique_results = {res['link']: res for res in combined_results}  # Remove duplicates
        ranked_results = rank_results(list(unique_results.values()), student_solution)

        for idx, result in enumerate(ranked_results, 1):
            print(f"\n{idx}. {result['title']} (from {result['engine']})")
            print(f"   {result['link']}")
            print(f"   {result['snippet']}")
    else:
        print("\nNo relevant results found.")

    print(f"\nTotal time taken: {time_taken} seconds")